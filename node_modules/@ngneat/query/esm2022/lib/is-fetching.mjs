import { notifyManager } from '@tanstack/query-core';
import { injectQueryClient } from './query-client';
import { assertInInjectionContext, inject, Injectable, InjectionToken, } from '@angular/core';
import { distinctUntilChanged, Observable } from 'rxjs';
import { toSignal } from '@angular/core/rxjs-interop';
import * as i0 from "@angular/core";
export class IsFetching {
    #queryClient = injectQueryClient();
    use(filters) {
        const result$ = new Observable((observer) => {
            observer.next(this.#queryClient.isFetching(filters));
            const disposeSubscription = this.#queryClient.getQueryCache().subscribe(notifyManager.batchCalls(() => {
                observer.next(this.#queryClient.isFetching(filters));
            }));
            return () => disposeSubscription();
        }).pipe(distinctUntilChanged());
        return {
            result$,
            toSignal: () => toSignal(result$),
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.1.3", ngImport: i0, type: IsFetching, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.1.3", ngImport: i0, type: IsFetching, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.1.3", ngImport: i0, type: IsFetching, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
const UseIsFetching = new InjectionToken('UseIsFetching', {
    providedIn: 'root',
    factory() {
        const isFetching = new IsFetching();
        return isFetching.use.bind(isFetching);
    },
});
export function injectIsFetching() {
    assertInInjectionContext(injectIsFetching);
    return inject(UseIsFetching);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXMtZmV0Y2hpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9xdWVyeS9zcmMvbGliL2lzLWZldGNoaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxhQUFhLEVBQXFCLE1BQU0sc0JBQXNCLENBQUM7QUFDeEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkQsT0FBTyxFQUNMLHdCQUF3QixFQUN4QixNQUFNLEVBQ04sVUFBVSxFQUNWLGNBQWMsR0FDZixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3hELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQzs7QUFHdEQsTUFBTSxPQUFPLFVBQVU7SUFDckIsWUFBWSxHQUFHLGlCQUFpQixFQUFFLENBQUM7SUFFbkMsR0FBRyxDQUFDLE9BQXNCO1FBQ3hCLE1BQU0sT0FBTyxHQUFHLElBQUksVUFBVSxDQUFTLENBQUMsUUFBUSxFQUFFLEVBQUU7WUFDbEQsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3JELE1BQU0sbUJBQW1CLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxTQUFTLENBQ3JFLGFBQWEsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFO2dCQUM1QixRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDdkQsQ0FBQyxDQUFDLENBQ0gsQ0FBQztZQUVGLE9BQU8sR0FBRyxFQUFFLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUNyQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDO1FBRWhDLE9BQU87WUFDTCxPQUFPO1lBQ1AsUUFBUSxFQUFFLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7U0FDbEMsQ0FBQztJQUNKLENBQUM7OEdBbkJVLFVBQVU7a0hBQVYsVUFBVSxjQURHLE1BQU07OzJGQUNuQixVQUFVO2tCQUR0QixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTs7QUF1QmxDLE1BQU0sYUFBYSxHQUFHLElBQUksY0FBYyxDQUFvQixlQUFlLEVBQUU7SUFDM0UsVUFBVSxFQUFFLE1BQU07SUFDbEIsT0FBTztRQUNMLE1BQU0sVUFBVSxHQUFHLElBQUksVUFBVSxFQUFFLENBQUM7UUFDcEMsT0FBTyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN6QyxDQUFDO0NBQ0YsQ0FBQyxDQUFDO0FBRUgsTUFBTSxVQUFVLGdCQUFnQjtJQUM5Qix3QkFBd0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzNDLE9BQU8sTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQy9CLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub3RpZnlNYW5hZ2VyLCB0eXBlIFF1ZXJ5RmlsdGVycyB9IGZyb20gJ0B0YW5zdGFjay9xdWVyeS1jb3JlJztcbmltcG9ydCB7IGluamVjdFF1ZXJ5Q2xpZW50IH0gZnJvbSAnLi9xdWVyeS1jbGllbnQnO1xuaW1wb3J0IHtcbiAgYXNzZXJ0SW5JbmplY3Rpb25Db250ZXh0LFxuICBpbmplY3QsXG4gIEluamVjdGFibGUsXG4gIEluamVjdGlvblRva2VuLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0b1NpZ25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcnhqcy1pbnRlcm9wJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBJc0ZldGNoaW5nIHtcbiAgI3F1ZXJ5Q2xpZW50ID0gaW5qZWN0UXVlcnlDbGllbnQoKTtcblxuICB1c2UoZmlsdGVycz86IFF1ZXJ5RmlsdGVycykge1xuICAgIGNvbnN0IHJlc3VsdCQgPSBuZXcgT2JzZXJ2YWJsZTxudW1iZXI+KChvYnNlcnZlcikgPT4ge1xuICAgICAgb2JzZXJ2ZXIubmV4dCh0aGlzLiNxdWVyeUNsaWVudC5pc0ZldGNoaW5nKGZpbHRlcnMpKTtcbiAgICAgIGNvbnN0IGRpc3Bvc2VTdWJzY3JpcHRpb24gPSB0aGlzLiNxdWVyeUNsaWVudC5nZXRRdWVyeUNhY2hlKCkuc3Vic2NyaWJlKFxuICAgICAgICBub3RpZnlNYW5hZ2VyLmJhdGNoQ2FsbHMoKCkgPT4ge1xuICAgICAgICAgIG9ic2VydmVyLm5leHQodGhpcy4jcXVlcnlDbGllbnQuaXNGZXRjaGluZyhmaWx0ZXJzKSk7XG4gICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuICgpID0+IGRpc3Bvc2VTdWJzY3JpcHRpb24oKTtcbiAgICB9KS5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdCQsXG4gICAgICB0b1NpZ25hbDogKCkgPT4gdG9TaWduYWwocmVzdWx0JCksXG4gICAgfTtcbiAgfVxufVxuXG5jb25zdCBVc2VJc0ZldGNoaW5nID0gbmV3IEluamVjdGlvblRva2VuPElzRmV0Y2hpbmdbJ3VzZSddPignVXNlSXNGZXRjaGluZycsIHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxuICBmYWN0b3J5KCkge1xuICAgIGNvbnN0IGlzRmV0Y2hpbmcgPSBuZXcgSXNGZXRjaGluZygpO1xuICAgIHJldHVybiBpc0ZldGNoaW5nLnVzZS5iaW5kKGlzRmV0Y2hpbmcpO1xuICB9LFxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RJc0ZldGNoaW5nKCkge1xuICBhc3NlcnRJbkluamVjdGlvbkNvbnRleHQoaW5qZWN0SXNGZXRjaGluZyk7XG4gIHJldHVybiBpbmplY3QoVXNlSXNGZXRjaGluZyk7XG59XG4iXX0=