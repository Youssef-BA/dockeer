import { assertInInjectionContext } from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import { notifyManager, } from '@tanstack/query-core';
import { Observable, shareReplay } from 'rxjs';
import { normalizeOptions } from './query-options';
import { shouldThrowError } from './utils';
export function createBaseQuery({ client, Observer, options, injector, }) {
    let queryObserver;
    const defaultedOptions = normalizeOptions(client, options, injector);
    const result$ = new Observable((observer) => {
        // Lazily create the observer when the first subscription is received
        if (!queryObserver) {
            queryObserver = new Observer(client, defaultedOptions);
        }
        observer.next(queryObserver.getOptimisticResult(defaultedOptions));
        const queryObserverDispose = queryObserver.subscribe(notifyManager.batchCalls((result) => {
            if (!result.isFetching &&
                result.isError &&
                shouldThrowError(queryObserver.options.throwOnError, [
                    result.error,
                    queryObserver.getCurrentQuery(),
                ])) {
                observer.error(result.error);
            }
            else {
                observer.next(defaultedOptions.notifyOnChangeProps
                    ? result
                    : queryObserver?.trackResult(result));
            }
        }));
        return () => {
            queryObserverDispose();
            queryObserver = undefined;
        };
    }).pipe(shareReplay({
        bufferSize: 1,
        refCount: true,
    }));
    let cachedSignal;
    const isNodeInjector = injector && injector['_tNode'];
    return {
        result$,
        updateOptions: (newOptions) => {
            if (queryObserver) {
                const normalized = normalizeOptions(client, {
                    ...options,
                    ...newOptions,
                }, injector);
                queryObserver.setOptions(normalized, { listeners: false });
            }
        },
        // @experimental signal support
        get result() {
            !isNodeInjector &&
                assertInInjectionContext(function queryResultSignal() {
                    // noop
                });
            if (!cachedSignal) {
                cachedSignal = toSignal(this.result$, {
                    requireSync: true,
                    // R3Injector isn't good here because it will cause a leak
                    // We only need the NodeInjector as we want the subscription to be destroyed when the component is destroyed
                    // We check that it's a NodeInjector by checking if it has a _tNode property
                    // Otherwise we just pass undefined and it'll use the current injector
                    // and not the R3Injector that we pass in the service
                    injector: isNodeInjector ? injector : undefined,
                });
            }
            return cachedSignal;
        },
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1xdWVyeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3F1ZXJ5L3NyYy9saWIvYmFzZS1xdWVyeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQW9CLHdCQUF3QixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUN0RCxPQUFPLEVBUUwsYUFBYSxHQUNkLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbkQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sU0FBUyxDQUFDO0FBdUQzQyxNQUFNLFVBQVUsZUFBZSxDQU03QixFQUNBLE1BQU0sRUFDTixRQUFRLEVBQ1IsT0FBTyxFQUNQLFFBQVEsR0FZVDtJQUNDLElBQUksYUFFUyxDQUFDO0lBRWQsTUFBTSxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FDdkMsTUFBTSxFQUNOLE9BTUMsRUFDRCxRQUFRLENBQ1QsQ0FBQztJQUVGLE1BQU0sT0FBTyxHQUFHLElBQUksVUFBVSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7UUFDMUMscUVBQXFFO1FBQ3JFLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUNuQixhQUFhLEdBQUcsSUFBSSxRQUFRLENBTTFCLE1BQU0sRUFBRSxnQkFBdUIsQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFFRCxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxnQkFBdUIsQ0FBQyxDQUFDLENBQUM7UUFFMUUsTUFBTSxvQkFBb0IsR0FBRyxhQUFhLENBQUMsU0FBUyxDQUNsRCxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDbEMsSUFDRSxDQUFDLE1BQU0sQ0FBQyxVQUFVO2dCQUNsQixNQUFNLENBQUMsT0FBTztnQkFDZCxnQkFBZ0IsQ0FBQyxhQUFjLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRTtvQkFDcEQsTUFBTSxDQUFDLEtBQUs7b0JBQ1osYUFBYyxDQUFDLGVBQWUsRUFBRTtpQkFDakMsQ0FBQyxFQUNGLENBQUM7Z0JBQ0QsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDL0IsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLFFBQVEsQ0FBQyxJQUFJLENBQ1gsZ0JBQWdCLENBQUMsbUJBQW1CO29CQUNsQyxDQUFDLENBQUMsTUFBTTtvQkFDUixDQUFDLENBQUMsYUFBYSxFQUFFLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FDdkMsQ0FBQztZQUNKLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FDSCxDQUFDO1FBRUYsT0FBTyxHQUFHLEVBQUU7WUFDVixvQkFBb0IsRUFBRSxDQUFDO1lBQ3ZCLGFBQWEsR0FBRyxTQUFTLENBQUM7UUFDNUIsQ0FBQyxDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUNMLFdBQVcsQ0FBQztRQUNWLFVBQVUsRUFBRSxDQUFDO1FBQ2IsUUFBUSxFQUFFLElBQUk7S0FDZixDQUFDLENBQ0gsQ0FBQztJQUVGLElBQUksWUFBcUMsQ0FBQztJQUMxQyxNQUFNLGNBQWMsR0FBRyxRQUFRLElBQUssUUFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUUvRCxPQUFPO1FBQ0wsT0FBTztRQUNQLGFBQWEsRUFBRSxDQUFDLFVBQXlDLEVBQUUsRUFBRTtZQUMzRCxJQUFJLGFBQWEsRUFBRSxDQUFDO2dCQUNsQixNQUFNLFVBQVUsR0FBRyxnQkFBZ0IsQ0FDakMsTUFBTSxFQUNOO29CQUNFLEdBQUksT0FBMkM7b0JBQy9DLEdBQUcsVUFBVTtpQkFDZCxFQUNELFFBQVEsQ0FPVCxDQUFDO2dCQUVGLGFBQWEsQ0FBQyxVQUFVLENBQUMsVUFBVSxFQUFFLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDN0QsQ0FBQztRQUNILENBQUM7UUFDRCwrQkFBK0I7UUFDL0IsSUFBSSxNQUFNO1lBQ1IsQ0FBQyxjQUFjO2dCQUNiLHdCQUF3QixDQUFDLFNBQVMsaUJBQWlCO29CQUNqRCxPQUFPO2dCQUNULENBQUMsQ0FBQyxDQUFDO1lBRUwsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO2dCQUNsQixZQUFZLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7b0JBQ3BDLFdBQVcsRUFBRSxJQUFJO29CQUNqQiwwREFBMEQ7b0JBQzFELDRHQUE0RztvQkFDNUcsNEVBQTRFO29CQUM1RSxzRUFBc0U7b0JBQ3RFLHFEQUFxRDtvQkFDckQsUUFBUSxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTO2lCQUNoRCxDQUFDLENBQUM7WUFDTCxDQUFDO1lBRUQsT0FBTyxZQUFZLENBQUM7UUFDdEIsQ0FBQztLQUNGLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0b3IsIFNpZ25hbCwgYXNzZXJ0SW5JbmplY3Rpb25Db250ZXh0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0b1NpZ25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcnhqcy1pbnRlcm9wJztcbmltcG9ydCB7XG4gIERlZmF1bHRFcnJvcixcbiAgUXVlcnlDbGllbnQsXG4gIFF1ZXJ5RnVuY3Rpb25Db250ZXh0LFxuICBRdWVyeUtleSxcbiAgUXVlcnlPYnNlcnZlcixcbiAgUXVlcnlPYnNlcnZlck9wdGlvbnMsXG4gIFdpdGhSZXF1aXJlZCxcbiAgbm90aWZ5TWFuYWdlcixcbn0gZnJvbSAnQHRhbnN0YWNrL3F1ZXJ5LWNvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgc2hhcmVSZXBsYXkgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZU9wdGlvbnMgfSBmcm9tICcuL3F1ZXJ5LW9wdGlvbnMnO1xuaW1wb3J0IHsgc2hvdWxkVGhyb3dFcnJvciB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBRdWVyeUZ1bmN0aW9uV2l0aE9ic2VydmFibGU8XG4gIFQgPSB1bmtub3duLFxuICBUUXVlcnlLZXkgZXh0ZW5kcyBRdWVyeUtleSA9IFF1ZXJ5S2V5LFxuICBUUGFnZVBhcmFtID0gbmV2ZXIsXG4+ID0gKFxuICBjb250ZXh0OiBRdWVyeUZ1bmN0aW9uQ29udGV4dDxUUXVlcnlLZXksIFRQYWdlUGFyYW0+LFxuKSA9PiBUIHwgUHJvbWlzZTxUPiB8IE9ic2VydmFibGU8VD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyB7XG4gIGluamVjdG9yPzogSW5qZWN0b3I7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgX0NyZWF0ZUJhc2VRdWVyeU9wdGlvbnM8XG4gIFRRdWVyeUZuRGF0YSA9IHVua25vd24sXG4gIFRFcnJvciA9IERlZmF1bHRFcnJvcixcbiAgVERhdGEgPSBUUXVlcnlGbkRhdGEsXG4gIFRRdWVyeURhdGEgPSBUUXVlcnlGbkRhdGEsXG4gIFRRdWVyeUtleSBleHRlbmRzIFF1ZXJ5S2V5ID0gUXVlcnlLZXksXG4gIFRQYWdlUGFyYW0gPSBuZXZlcixcbj4gZXh0ZW5kcyBXaXRoUmVxdWlyZWQ8XG4gICAgICBRdWVyeU9ic2VydmVyT3B0aW9uczxcbiAgICAgICAgVFF1ZXJ5Rm5EYXRhLFxuICAgICAgICBURXJyb3IsXG4gICAgICAgIFREYXRhLFxuICAgICAgICBUUXVlcnlEYXRhLFxuICAgICAgICBUUXVlcnlLZXksXG4gICAgICAgIFRQYWdlUGFyYW1cbiAgICAgID4sXG4gICAgICAncXVlcnlLZXknXG4gICAgPixcbiAgICBPcHRpb25zIHt9XG5cbmV4cG9ydCB0eXBlIENyZWF0ZUJhc2VRdWVyeU9wdGlvbnM8XG4gIFRRdWVyeUZuRGF0YSA9IHVua25vd24sXG4gIFRFcnJvciA9IERlZmF1bHRFcnJvcixcbiAgVERhdGEgPSBUUXVlcnlGbkRhdGEsXG4gIFRRdWVyeURhdGEgPSBUUXVlcnlGbkRhdGEsXG4gIFRRdWVyeUtleSBleHRlbmRzIFF1ZXJ5S2V5ID0gUXVlcnlLZXksXG4gIFRQYWdlUGFyYW0gPSBuZXZlcixcbj4gPSBPbWl0PFxuICBfQ3JlYXRlQmFzZVF1ZXJ5T3B0aW9uczxcbiAgICBUUXVlcnlGbkRhdGEsXG4gICAgVEVycm9yLFxuICAgIFREYXRhLFxuICAgIFRRdWVyeURhdGEsXG4gICAgVFF1ZXJ5S2V5LFxuICAgIFRQYWdlUGFyYW1cbiAgPixcbiAgJ3F1ZXJ5Rm4nXG4+ICYge1xuICBxdWVyeUZuOiBRdWVyeUZ1bmN0aW9uV2l0aE9ic2VydmFibGU8VFF1ZXJ5Rm5EYXRhLCBUUXVlcnlLZXk+O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJhc2VRdWVyeTxcbiAgVFF1ZXJ5Rm5EYXRhLFxuICBURXJyb3IsXG4gIFREYXRhLFxuICBUUXVlcnlEYXRhLFxuICBUUXVlcnlLZXkgZXh0ZW5kcyBRdWVyeUtleSxcbj4oe1xuICBjbGllbnQsXG4gIE9ic2VydmVyLFxuICBvcHRpb25zLFxuICBpbmplY3Rvcixcbn06IHtcbiAgY2xpZW50OiBRdWVyeUNsaWVudDtcbiAgT2JzZXJ2ZXI6IHR5cGVvZiBRdWVyeU9ic2VydmVyO1xuICBvcHRpb25zOiBDcmVhdGVCYXNlUXVlcnlPcHRpb25zPFxuICAgIFRRdWVyeUZuRGF0YSxcbiAgICBURXJyb3IsXG4gICAgVERhdGEsXG4gICAgVFF1ZXJ5RGF0YSxcbiAgICBUUXVlcnlLZXlcbiAgPjtcbiAgaW5qZWN0b3I6IEluamVjdG9yO1xufSk6IGFueSB7XG4gIGxldCBxdWVyeU9ic2VydmVyOlxuICAgIHwgUXVlcnlPYnNlcnZlcjxUUXVlcnlGbkRhdGEsIFRFcnJvciwgVERhdGEsIFRRdWVyeURhdGEsIFRRdWVyeUtleT5cbiAgICB8IHVuZGVmaW5lZDtcblxuICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucyhcbiAgICBjbGllbnQsXG4gICAgb3B0aW9ucyBhcyBRdWVyeU9ic2VydmVyT3B0aW9uczxcbiAgICAgIFRRdWVyeUZuRGF0YSxcbiAgICAgIFRFcnJvcixcbiAgICAgIFREYXRhLFxuICAgICAgVFF1ZXJ5RGF0YSxcbiAgICAgIFRRdWVyeUtleVxuICAgID4sXG4gICAgaW5qZWN0b3IsXG4gICk7XG5cbiAgY29uc3QgcmVzdWx0JCA9IG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgIC8vIExhemlseSBjcmVhdGUgdGhlIG9ic2VydmVyIHdoZW4gdGhlIGZpcnN0IHN1YnNjcmlwdGlvbiBpcyByZWNlaXZlZFxuICAgIGlmICghcXVlcnlPYnNlcnZlcikge1xuICAgICAgcXVlcnlPYnNlcnZlciA9IG5ldyBPYnNlcnZlcjxcbiAgICAgICAgVFF1ZXJ5Rm5EYXRhLFxuICAgICAgICBURXJyb3IsXG4gICAgICAgIFREYXRhLFxuICAgICAgICBUUXVlcnlEYXRhLFxuICAgICAgICBUUXVlcnlLZXlcbiAgICAgID4oY2xpZW50LCBkZWZhdWx0ZWRPcHRpb25zIGFzIGFueSk7XG4gICAgfVxuXG4gICAgb2JzZXJ2ZXIubmV4dChxdWVyeU9ic2VydmVyLmdldE9wdGltaXN0aWNSZXN1bHQoZGVmYXVsdGVkT3B0aW9ucyBhcyBhbnkpKTtcblxuICAgIGNvbnN0IHF1ZXJ5T2JzZXJ2ZXJEaXNwb3NlID0gcXVlcnlPYnNlcnZlci5zdWJzY3JpYmUoXG4gICAgICBub3RpZnlNYW5hZ2VyLmJhdGNoQ2FsbHMoKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXJlc3VsdC5pc0ZldGNoaW5nICYmXG4gICAgICAgICAgcmVzdWx0LmlzRXJyb3IgJiZcbiAgICAgICAgICBzaG91bGRUaHJvd0Vycm9yKHF1ZXJ5T2JzZXJ2ZXIhLm9wdGlvbnMudGhyb3dPbkVycm9yLCBbXG4gICAgICAgICAgICByZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICBxdWVyeU9ic2VydmVyIS5nZXRDdXJyZW50UXVlcnkoKSxcbiAgICAgICAgICBdKVxuICAgICAgICApIHtcbiAgICAgICAgICBvYnNlcnZlci5lcnJvcihyZXN1bHQuZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9ic2VydmVyLm5leHQoXG4gICAgICAgICAgICBkZWZhdWx0ZWRPcHRpb25zLm5vdGlmeU9uQ2hhbmdlUHJvcHNcbiAgICAgICAgICAgICAgPyByZXN1bHRcbiAgICAgICAgICAgICAgOiBxdWVyeU9ic2VydmVyPy50cmFja1Jlc3VsdChyZXN1bHQpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcXVlcnlPYnNlcnZlckRpc3Bvc2UoKTtcbiAgICAgIHF1ZXJ5T2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgfSkucGlwZShcbiAgICBzaGFyZVJlcGxheSh7XG4gICAgICBidWZmZXJTaXplOiAxLFxuICAgICAgcmVmQ291bnQ6IHRydWUsXG4gICAgfSksXG4gICk7XG5cbiAgbGV0IGNhY2hlZFNpZ25hbDogdW5kZWZpbmVkIHwgU2lnbmFsPGFueT47XG4gIGNvbnN0IGlzTm9kZUluamVjdG9yID0gaW5qZWN0b3IgJiYgKGluamVjdG9yIGFzIGFueSlbJ190Tm9kZSddO1xuXG4gIHJldHVybiB7XG4gICAgcmVzdWx0JCxcbiAgICB1cGRhdGVPcHRpb25zOiAobmV3T3B0aW9uczogUGFydGlhbDxRdWVyeU9ic2VydmVyT3B0aW9ucz4pID0+IHtcbiAgICAgIGlmIChxdWVyeU9ic2VydmVyKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVPcHRpb25zKFxuICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi4ob3B0aW9ucyBhcyB1bmtub3duIGFzIFF1ZXJ5T2JzZXJ2ZXJPcHRpb25zKSxcbiAgICAgICAgICAgIC4uLm5ld09wdGlvbnMsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmplY3RvcixcbiAgICAgICAgKSBhcyBRdWVyeU9ic2VydmVyT3B0aW9uczxcbiAgICAgICAgICBUUXVlcnlGbkRhdGEsXG4gICAgICAgICAgVEVycm9yLFxuICAgICAgICAgIFREYXRhLFxuICAgICAgICAgIFRRdWVyeURhdGEsXG4gICAgICAgICAgVFF1ZXJ5S2V5XG4gICAgICAgID47XG5cbiAgICAgICAgcXVlcnlPYnNlcnZlci5zZXRPcHRpb25zKG5vcm1hbGl6ZWQsIHsgbGlzdGVuZXJzOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEBleHBlcmltZW50YWwgc2lnbmFsIHN1cHBvcnRcbiAgICBnZXQgcmVzdWx0KCkge1xuICAgICAgIWlzTm9kZUluamVjdG9yICYmXG4gICAgICAgIGFzc2VydEluSW5qZWN0aW9uQ29udGV4dChmdW5jdGlvbiBxdWVyeVJlc3VsdFNpZ25hbCgpIHtcbiAgICAgICAgICAvLyBub29wXG4gICAgICAgIH0pO1xuXG4gICAgICBpZiAoIWNhY2hlZFNpZ25hbCkge1xuICAgICAgICBjYWNoZWRTaWduYWwgPSB0b1NpZ25hbCh0aGlzLnJlc3VsdCQsIHtcbiAgICAgICAgICByZXF1aXJlU3luYzogdHJ1ZSxcbiAgICAgICAgICAvLyBSM0luamVjdG9yIGlzbid0IGdvb2QgaGVyZSBiZWNhdXNlIGl0IHdpbGwgY2F1c2UgYSBsZWFrXG4gICAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRoZSBOb2RlSW5qZWN0b3IgYXMgd2Ugd2FudCB0aGUgc3Vic2NyaXB0aW9uIHRvIGJlIGRlc3Ryb3llZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkXG4gICAgICAgICAgLy8gV2UgY2hlY2sgdGhhdCBpdCdzIGEgTm9kZUluamVjdG9yIGJ5IGNoZWNraW5nIGlmIGl0IGhhcyBhIF90Tm9kZSBwcm9wZXJ0eVxuICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBqdXN0IHBhc3MgdW5kZWZpbmVkIGFuZCBpdCdsbCB1c2UgdGhlIGN1cnJlbnQgaW5qZWN0b3JcbiAgICAgICAgICAvLyBhbmQgbm90IHRoZSBSM0luamVjdG9yIHRoYXQgd2UgcGFzcyBpbiB0aGUgc2VydmljZVxuICAgICAgICAgIGluamVjdG9yOiBpc05vZGVJbmplY3RvciA/IGluamVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlZFNpZ25hbDtcbiAgICB9LFxuICB9O1xufVxuIl19