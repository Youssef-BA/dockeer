{"version":3,"file":"ngneat-query.mjs","sources":["../../../query/src/lib/query-client-options.ts","../../../query/src/lib/utils.ts","../../../query/src/lib/query-options.ts","../../../query/src/lib/query-client.ts","../../../query/src/lib/base-query.ts","../../../query/src/lib/infinite-query.ts","../../../query/src/lib/is-fetching.ts","../../../query/src/lib/is-mutating.ts","../../../query/src/lib/mutation.ts","../../../query/src/lib/query.ts","../../../query/src/lib/operators.ts","../../../query/src/lib/signals.ts","../../../query/src/ngneat-query.ts"],"sourcesContent":["import {\n  EnvironmentProviders,\n  InjectionToken,\n  makeEnvironmentProviders,\n} from '@angular/core';\nimport { QueryClientConfig } from '@tanstack/query-core';\n\nexport const QUERY_CLIENT_OPTIONS = new InjectionToken<QueryClientConfig>(\n  'QUERY_CLIENT_OPTIONS',\n  {\n    providedIn: 'root',\n    factory() {\n      return {};\n    },\n  },\n);\n\nexport type QueryClientConfigFn = () => QueryClientConfig;\n\nexport function provideQueryClientOptions(\n  options: QueryClientConfig,\n): EnvironmentProviders;\nexport function provideQueryClientOptions(\n  options: QueryClientConfigFn,\n): EnvironmentProviders;\nexport function provideQueryClientOptions(\n  options: QueryClientConfig | QueryClientConfigFn,\n) {\n  return makeEnvironmentProviders([\n    {\n      provide: QUERY_CLIENT_OPTIONS,\n      [typeof options === 'function' ? 'useFactory' : 'useValue']: options,\n    } as any,\n  ]);\n}\n","import {\n  DefaultError,\n  QueryObserverResult,\n  QueryObserverSuccessResult,\n} from '@tanstack/query-core';\nimport { Observable, Subject, firstValueFrom, takeUntil } from 'rxjs';\n\nexport function toPromise<T>({\n  source,\n  signal,\n}: {\n  source: Observable<T>;\n  signal?: AbortSignal;\n}): Promise<T> {\n  const cancel = new Subject<void>();\n\n  if (signal) {\n    signal.addEventListener('abort', () => {\n      cancel.next();\n      cancel.complete();\n    });\n  }\n\n  return firstValueFrom(source.pipe(signal ? takeUntil(cancel) : (s) => s));\n}\n\nexport function createSuccessObserverResult<T, Error = DefaultError>(\n  data: T,\n): QueryObserverResult<T, Error> {\n  return {\n    data,\n    isLoading: false,\n    isError: false,\n    isFetching: false,\n    isPending: false,\n    isSuccess: true,\n    status: 'success',\n  } as QueryObserverSuccessResult<T, Error>;\n}\n\nexport function createPendingObserverResult<\n  T = unknown,\n  Error = DefaultError,\n>(): QueryObserverResult<T, Error> {\n  return {\n    isError: false,\n    isLoading: true,\n    isPending: true,\n    isFetching: true,\n    isSuccess: false,\n    fetchStatus: 'fetching',\n    status: 'pending',\n  } as QueryObserverResult<T, Error>;\n}\n\nexport function shouldThrowError<T extends (...args: Array<any>) => boolean>(\n  throwError: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  if (typeof throwError === 'function') {\n    return throwError(...params);\n  }\n\n  return !!throwError;\n}\n","import { Injector, runInInjectionContext } from '@angular/core';\nimport type {\n  DataTag,\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  QueryClient,\n  QueryFunctionContext,\n  QueryKey,\n  QueryObserverOptions,\n} from '@tanstack/query-core';\nimport { isObservable } from 'rxjs';\nimport { CreateBaseQueryOptions } from './base-query';\nimport { CreateInfiniteQueryOptions } from './infinite-query';\nimport { toPromise } from './utils';\n\nexport type UndefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = CreateBaseQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryFnData,\n  TQueryKey\n> & {\n  initialData?: undefined;\n};\n\ntype NonUndefinedGuard<T> = T extends undefined ? never : T;\n\nexport type DefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = CreateBaseQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryFnData,\n  TQueryKey\n> & {\n  initialData:\n    | NonUndefinedGuard<TQueryFnData>\n    | (() => NonUndefinedGuard<TQueryFnData>);\n};\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TData>;\n};\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TData>;\n};\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n>(\n  options: CreateInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n): CreateInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TQueryFnData,\n  TQueryFnData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, TData>;\n};\nexport function queryOptions(options: unknown) {\n  return options;\n}\n\nexport function normalizeOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n  TPageParam = never,\n>(\n  client: QueryClient,\n  options: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey,\n    TPageParam\n  >,\n  injector: Injector,\n): DefaultedQueryObserverOptions<unknown, Error, unknown, unknown, QueryKey> {\n  const defaultedOptions = client.defaultQueryOptions(\n    options as unknown as QueryObserverOptions,\n  );\n  defaultedOptions._optimisticResults = 'optimistic';\n\n  const originalQueryFn = defaultedOptions.queryFn;\n\n  if (originalQueryFn) {\n    defaultedOptions.queryFn = function (ctx: QueryFunctionContext) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const _this = this;\n\n      return runInInjectionContext(injector, () => {\n        const value = originalQueryFn.call(_this, ctx);\n\n        if (isObservable(value)) {\n          return toPromise({ source: value, signal: ctx.signal });\n        }\n\n        return value;\n      });\n    };\n  }\n\n  return defaultedOptions;\n}\n","import { isPlatformBrowser } from '@angular/common';\nimport {\n  inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  OnDestroy,\n  PLATFORM_ID,\n  Provider,\n} from '@angular/core';\nimport {\n  QueryClient as _QueryClient,\n  DefaultError,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  QueryKey,\n  QueryObserverOptions,\n} from '@tanstack/query-core';\nimport { CreateBaseQueryOptions } from './base-query';\nimport { CreateInfiniteQueryOptions } from './infinite-query';\nimport { QUERY_CLIENT_OPTIONS } from './query-client-options';\nimport { normalizeOptions } from './query-options';\n\nconst QueryClientToken = new InjectionToken<QueryClient>('QueryClient', {\n  providedIn: 'root',\n  factory() {\n    return new QueryClient(inject(QUERY_CLIENT_OPTIONS));\n  },\n});\n\n@Injectable({\n  providedIn: 'root',\n})\nclass QueryClientMount implements OnDestroy {\n  instance = inject(QueryClientToken);\n\n  constructor() {\n    this.instance.mount();\n  }\n\n  ngOnDestroy() {\n    this.instance.unmount();\n  }\n}\n\nconst QueryClientService = new InjectionToken<QueryClient>(\n  'QueryClientService',\n  {\n    providedIn: 'root',\n    factory() {\n      if (isPlatformBrowser(inject(PLATFORM_ID))) {\n        inject(QueryClientMount);\n      }\n\n      return inject(QueryClientToken);\n    },\n  },\n);\n\n/** @public */\nexport function provideQueryClient(queryClient: QueryClient): Provider {\n  return {\n    provide: QueryClientToken,\n    useValue: queryClient,\n  };\n}\n\n/** @public */\nexport function injectQueryClient() {\n  return inject(QueryClientService);\n}\n\n/** should be exported for @test */\nexport class QueryClient extends _QueryClient {\n  #injector = inject(Injector);\n\n  /**\n   *\n   * Asynchronous function that can be used to get an existing query's cached data.\n   * If the query does not exist, queryClient.fetchQuery will be called and its results\n   * returned.\n   *\n   * @example\n   *\n   * queryClient = injectQueryClient();\n   *\n   * const data = await queryClient.ensureQueryData({ queryKey, queryFn })\n   *\n   */\n  override ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: CreateBaseQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n  ): Promise<TData>;\n  override ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey, never>,\n  ): Promise<TData>;\n  override ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: CreateBaseQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = normalizeOptions(\n      this,\n      options as QueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n      this.#injector,\n    ) as unknown as FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      never\n    >;\n    return super.ensureQueryData(defaultedOptions);\n  }\n\n  /**\n   *\n   * Asynchronous method that can be used to fetch and cache a query.\n   * It will either resolve with the data or throw with the error.\n   * Use the prefetchQuery method if you just want to fetch a query without\n   * needing the result.\n   * If the query exists and the data is not invalidated or older than the given\n   * staleTime, then the data from the cache will be returned.\n   * Otherwise it will try to fetch the latest data.\n   *\n   * @example\n   *\n   * queryClient = injectQueryClient();\n   *\n   * const data = await queryClient.fetchQuery({ queryKey, queryFn })\n   *\n   */\n  override fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: CreateBaseQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData>;\n  override fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData>;\n  override fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: CreateBaseQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = normalizeOptions(\n      this,\n      options as QueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey,\n        TPageParam\n      >,\n      this.#injector,\n    ) as unknown as FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >;\n    return super.fetchQuery(defaultedOptions);\n  }\n\n  /**\n   *\n   * Asynchronous method that can be used to prefetch a query before\n   * it is needed or rendered with useQuery and friends.\n   * The method works the same as fetchQuery except that it will not\n   * throw or return any data.\n   *\n   * @example\n   *\n   * queryClient = injectQueryClient();\n   *\n   * await queryClient.prefetchQuery({ queryKey, queryFn })\n   *\n   */\n  override prefetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: CreateBaseQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n  ): Promise<void>;\n  override prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>;\n  override prefetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: CreateBaseQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n  ): Promise<void> {\n    const defaultedOptions = normalizeOptions(\n      this,\n      options as QueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n      this.#injector,\n    ) as unknown as FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      never\n    >;\n    return super.prefetchQuery(defaultedOptions);\n  }\n\n  /**\n   *\n   * Similar to fetchQuery but can be used to fetch and cache an infinite query\n   *\n   * @example\n   *\n   * queryClient = injectQueryClient();\n   *\n   * const data = await queryClient.fetchInfiniteQuery({ queryKey, queryFn, initialPageParam, getPreviousPageParam, getNextPageParam }) })\n   *\n   */\n  override fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: CreateInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>>;\n  override fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>>;\n  override fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: CreateInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    const defaultedOptions = normalizeOptions(\n      this,\n      options as InfiniteQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TQueryFnData,\n        TQueryFnData,\n        TQueryKey,\n        TPageParam\n      >,\n      this.#injector,\n    ) as unknown as FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >;\n    return super.fetchInfiniteQuery(defaultedOptions);\n  }\n\n  /**\n   *\n   * Similar to prefetchQuery but can be used to prefetch and cache an infinite query.\n   *\n   * @example\n   *\n   * queryClient = injectQueryClient();\n   *\n   * await queryClient.prefetchInfiniteQuery({ queryKey, queryFn, initialPageParam, getPreviousPageParam, getNextPageParam })\n   *\n   */\n  override prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: CreateInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void>;\n  override prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void>;\n  override prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: CreateInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    const defaultedOptions = normalizeOptions(\n      this,\n      options as InfiniteQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TQueryFnData,\n        TQueryFnData,\n        TQueryKey,\n        TPageParam\n      >,\n      this.#injector,\n    ) as unknown as FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >;\n    return super.prefetchInfiniteQuery(defaultedOptions);\n  }\n}\n","import { Injector, Signal, assertInInjectionContext } from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport {\n  DefaultError,\n  QueryClient,\n  QueryFunctionContext,\n  QueryKey,\n  QueryObserver,\n  QueryObserverOptions,\n  WithRequired,\n  notifyManager,\n} from '@tanstack/query-core';\nimport { Observable, shareReplay } from 'rxjs';\nimport { normalizeOptions } from './query-options';\nimport { shouldThrowError } from './utils';\n\nexport type QueryFunctionWithObservable<\n  T = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = (\n  context: QueryFunctionContext<TQueryKey, TPageParam>,\n) => T | Promise<T> | Observable<T>;\n\nexport interface Options {\n  injector?: Injector;\n}\n\nexport interface _CreateBaseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends WithRequired<\n      QueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey,\n        TPageParam\n      >,\n      'queryKey'\n    >,\n    Options {}\n\nexport type CreateBaseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> = Omit<\n  _CreateBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey,\n    TPageParam\n  >,\n  'queryFn'\n> & {\n  queryFn: QueryFunctionWithObservable<TQueryFnData, TQueryKey>;\n};\n\nexport function createBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  client,\n  Observer,\n  options,\n  injector,\n}: {\n  client: QueryClient;\n  Observer: typeof QueryObserver;\n  options: CreateBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >;\n  injector: Injector;\n}): any {\n  let queryObserver:\n    | QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n    | undefined;\n\n  const defaultedOptions = normalizeOptions(\n    client,\n    options as QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    injector,\n  );\n\n  const result$ = new Observable((observer) => {\n    // Lazily create the observer when the first subscription is received\n    if (!queryObserver) {\n      queryObserver = new Observer<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >(client, defaultedOptions as any);\n    }\n\n    observer.next(queryObserver.getOptimisticResult(defaultedOptions as any));\n\n    const queryObserverDispose = queryObserver.subscribe(\n      notifyManager.batchCalls((result) => {\n        if (\n          !result.isFetching &&\n          result.isError &&\n          shouldThrowError(queryObserver!.options.throwOnError, [\n            result.error,\n            queryObserver!.getCurrentQuery(),\n          ])\n        ) {\n          observer.error(result.error);\n        } else {\n          observer.next(\n            defaultedOptions.notifyOnChangeProps\n              ? result\n              : queryObserver?.trackResult(result),\n          );\n        }\n      }),\n    );\n\n    return () => {\n      queryObserverDispose();\n      queryObserver = undefined;\n    };\n  }).pipe(\n    shareReplay({\n      bufferSize: 1,\n      refCount: true,\n    }),\n  );\n\n  let cachedSignal: undefined | Signal<any>;\n  const isNodeInjector = injector && (injector as any)['_tNode'];\n\n  return {\n    result$,\n    updateOptions: (newOptions: Partial<QueryObserverOptions>) => {\n      if (queryObserver) {\n        const normalized = normalizeOptions(\n          client,\n          {\n            ...(options as unknown as QueryObserverOptions),\n            ...newOptions,\n          },\n          injector,\n        ) as QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >;\n\n        queryObserver.setOptions(normalized, { listeners: false });\n      }\n    },\n    // @experimental signal support\n    get result() {\n      !isNodeInjector &&\n        assertInInjectionContext(function queryResultSignal() {\n          // noop\n        });\n\n      if (!cachedSignal) {\n        cachedSignal = toSignal(this.result$, {\n          requireSync: true,\n          // R3Injector isn't good here because it will cause a leak\n          // We only need the NodeInjector as we want the subscription to be destroyed when the component is destroyed\n          // We check that it's a NodeInjector by checking if it has a _tNode property\n          // Otherwise we just pass undefined and it'll use the current injector\n          // and not the R3Injector that we pass in the service\n          injector: isNodeInjector ? injector : undefined,\n        });\n      }\n\n      return cachedSignal;\n    },\n  };\n}\n","import {\n  assertInInjectionContext,\n  inject,\n  Injectable,\n  Injector,\n  runInInjectionContext,\n} from '@angular/core';\nimport { injectQueryClient } from './query-client';\n\nimport {\n  DefaultError,\n  InfiniteData,\n  InfiniteQueryObserver,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n  QueryObserver,\n  WithRequired,\n} from '@tanstack/query-core';\nimport {\n  createBaseQuery,\n  Options,\n  QueryFunctionWithObservable,\n} from './base-query';\nimport { Result } from './types';\n\ninterface _CreateInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends WithRequired<\n      InfiniteQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey,\n        TPageParam\n      >,\n      'queryKey'\n    >,\n    Options {}\n\nexport type CreateInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = Omit<\n  _CreateInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey,\n    TPageParam\n  >,\n  'queryFn'\n> & {\n  queryFn: QueryFunctionWithObservable<TQueryFnData, TQueryKey, TPageParam>;\n};\n\n@Injectable({ providedIn: 'root' })\nclass InfiniteQuery {\n  #instance = injectQueryClient();\n  #injector = inject(Injector);\n\n  use<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = InfiniteData<TQueryFnData>,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: CreateInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Result<InfiniteQueryObserverResult<TData, TError>> {\n    return createBaseQuery({\n      client: this.#instance,\n      injector: options.injector ?? this.#injector,\n      Observer: InfiniteQueryObserver as typeof QueryObserver,\n      options: options as any,\n    });\n  }\n}\n\nexport function injectInfiniteQuery(options?: { injector?: Injector }) {\n  if (options?.injector) {\n    return runInInjectionContext(options.injector, () => {\n      const query = inject(InfiniteQuery);\n\n      return query.use.bind(query);\n    });\n  }\n\n  assertInInjectionContext(injectInfiniteQuery);\n\n  const query = inject(InfiniteQuery);\n\n  return query.use.bind(query);\n}\n","import { notifyManager, type QueryFilters } from '@tanstack/query-core';\nimport { injectQueryClient } from './query-client';\nimport {\n  assertInInjectionContext,\n  inject,\n  Injectable,\n  InjectionToken,\n} from '@angular/core';\nimport { distinctUntilChanged, Observable } from 'rxjs';\nimport { toSignal } from '@angular/core/rxjs-interop';\n\n@Injectable({ providedIn: 'root' })\nexport class IsFetching {\n  #queryClient = injectQueryClient();\n\n  use(filters?: QueryFilters) {\n    const result$ = new Observable<number>((observer) => {\n      observer.next(this.#queryClient.isFetching(filters));\n      const disposeSubscription = this.#queryClient.getQueryCache().subscribe(\n        notifyManager.batchCalls(() => {\n          observer.next(this.#queryClient.isFetching(filters));\n        }),\n      );\n\n      return () => disposeSubscription();\n    }).pipe(distinctUntilChanged());\n\n    return {\n      result$,\n      toSignal: () => toSignal(result$),\n    };\n  }\n}\n\nconst UseIsFetching = new InjectionToken<IsFetching['use']>('UseIsFetching', {\n  providedIn: 'root',\n  factory() {\n    const isFetching = new IsFetching();\n    return isFetching.use.bind(isFetching);\n  },\n});\n\nexport function injectIsFetching() {\n  assertInInjectionContext(injectIsFetching);\n  return inject(UseIsFetching);\n}\n","import { type MutationFilters, notifyManager } from '@tanstack/query-core';\nimport { injectQueryClient } from './query-client';\nimport {\n  assertInInjectionContext,\n  inject,\n  Injectable,\n  InjectionToken,\n} from '@angular/core';\nimport { distinctUntilChanged, Observable } from 'rxjs';\nimport { toSignal } from '@angular/core/rxjs-interop';\n\n@Injectable({ providedIn: 'root' })\nexport class IsMutating {\n  #queryClient = injectQueryClient();\n\n  use(filters?: MutationFilters) {\n    const result$ = new Observable<number>((observer) => {\n      observer.next(this.#queryClient.isMutating(filters));\n      const disposeSubscription = this.#queryClient\n        .getMutationCache()\n        .subscribe(\n          notifyManager.batchCalls(() => {\n            observer.next(this.#queryClient.isMutating(filters));\n          }),\n        );\n\n      return () => disposeSubscription();\n    }).pipe(distinctUntilChanged());\n\n    return {\n      result$,\n      toSignal: () => toSignal(result$),\n    };\n  }\n}\n\nconst UseIsMutating = new InjectionToken<IsMutating['use']>('UseIsFetching', {\n  providedIn: 'root',\n  factory() {\n    const isMutating = new IsMutating();\n    return isMutating.use.bind(isMutating);\n  },\n});\n\nexport function injectIsMutating() {\n  assertInInjectionContext(injectIsMutating);\n\n  return inject(UseIsMutating);\n}\n","import { inject, Injectable, InjectionToken, Signal } from '@angular/core';\nimport { injectQueryClient } from './query-client';\nimport {\n  DefaultError,\n  MutateOptions,\n  MutationObserver,\n  MutationObserverOptions,\n  MutationObserverResult,\n  notifyManager,\n} from '@tanstack/query-core';\nimport { isObservable, Observable, shareReplay } from 'rxjs';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport { shouldThrowError, toPromise } from './utils';\n\nexport type CreateMutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = Omit<\n  MutationObserverOptions<TData, TError, TVariables, TContext>,\n  'mutationFn'\n> & {\n  mutationFn: (variables: TVariables) => Promise<TData> | Observable<TData>;\n};\n\nexport type MutationResult<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = {\n  mutateAsync: (\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ) => Promise<TData>;\n  mutate: (\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ) => void;\n  reset: MutationObserver<TData, TError, TVariables, TContext>['reset'];\n  setOptions: MutationObserver<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  >['setOptions'];\n  result$: Observable<\n    MutationObserverResult<TData, TError, TVariables, TContext>\n  >;\n  result: Signal<MutationObserverResult<TData, TError, TVariables, TContext>>;\n};\n\n@Injectable({ providedIn: 'root' })\nclass Mutation {\n  #instance = injectQueryClient();\n\n  use<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = unknown,\n    TContext = unknown,\n  >(\n    options: CreateMutationOptions<TData, TError, TVariables, TContext>,\n  ): MutationResult<TData, TError, TVariables, TContext> {\n    const mutationObserver = new MutationObserver<\n      TData,\n      TError,\n      TVariables,\n      TContext\n    >(this.#instance, {\n      ...options,\n      mutationFn: (variables: TVariables): Promise<TData> => {\n        const source: Promise<TData> | Observable<TData> =\n          options.mutationFn(variables);\n\n        if (isObservable(source)) return toPromise({ source });\n\n        return source;\n      },\n    });\n\n    const result$ = new Observable<\n      MutationObserverResult<TData, TError, TVariables, TContext>\n    >((observer) => {\n      observer.next(mutationObserver.getCurrentResult());\n\n      const disposeSubscription = mutationObserver.subscribe(\n        notifyManager.batchCalls(\n          (\n            result: MutationObserverResult<TData, TError, TVariables, TContext>,\n          ) => {\n            if (\n              result.isError &&\n              shouldThrowError(mutationObserver!.options.throwOnError, [\n                result.error,\n              ])\n            ) {\n              observer.error(result.error);\n            } else {\n              observer.next(result);\n            }\n          },\n        ),\n      );\n\n      return () => disposeSubscription();\n    }).pipe(\n      shareReplay({\n        bufferSize: 1,\n        refCount: true,\n      }),\n    );\n\n    const mutate = (\n      variables: TVariables,\n      options?: MutateOptions<TData, TError, TVariables, TContext>,\n    ) => {\n      mutationObserver.mutate(variables, options).catch(() => {\n        // noop\n      });\n    };\n\n    let cachedSignal: undefined | Signal<any>;\n\n    return {\n      mutate,\n      mutateAsync: mutationObserver.mutate.bind(mutationObserver),\n      reset: mutationObserver.reset.bind(mutationObserver),\n      setOptions: mutationObserver.setOptions.bind(mutationObserver),\n      result$,\n      // @experimental signal support\n      get result() {\n        if (!cachedSignal) {\n          cachedSignal = toSignal(this.result$, { requireSync: true });\n        }\n\n        return cachedSignal;\n      },\n    };\n  }\n}\n\nconst UseMutation = new InjectionToken('UseMutation', {\n  providedIn: 'root',\n  factory() {\n    const mutation = new Mutation();\n    return mutation.use.bind(mutation);\n  },\n});\n\nexport function injectMutation() {\n  return inject(UseMutation);\n}\n","import {\n  assertInInjectionContext,\n  inject,\n  Injectable,\n  Injector,\n  runInInjectionContext,\n} from '@angular/core';\nimport { injectQueryClient } from './query-client';\n\nimport {\n  DefaultError,\n  DefinedQueryObserverResult,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core';\nimport { createBaseQuery, CreateBaseQueryOptions } from './base-query';\nimport { Result } from './types';\nimport {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './query-options';\n\n@Injectable({ providedIn: 'root' })\nclass Query {\n  #instance = injectQueryClient();\n  #injector = inject(Injector);\n\n  use<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: UndefinedInitialDataOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    >,\n  ): Result<QueryObserverResult<TData, TError>>;\n\n  use<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Result<DefinedQueryObserverResult<TData, TError>>;\n\n  use<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: CreateBaseQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n  ) {\n    return createBaseQuery({\n      client: this.#instance,\n      injector: options.injector ?? this.#injector,\n      Observer: QueryObserver,\n      options,\n    });\n  }\n}\n\n/**\n *\n * Optionally pass an injector that will be used than the current one.\n * Can be useful if you want to use it in ngOnInit hook for example.\n *\n * @example\n *\n * injector = inject(Injector);\n *\n * ngOnInit() {\n *  const todos = getTodos({ injector: this.injector }).result;\n * }\n *\n */\nexport function injectQuery(options?: { injector?: Injector }) {\n  if (options?.injector) {\n    return runInInjectionContext(options.injector, () => {\n      const query = inject(Query);\n\n      return query.use.bind(query);\n    });\n  }\n\n  assertInInjectionContext(injectQuery);\n\n  const query = inject(Query);\n\n  return query.use.bind(query);\n}\n","import {\n  QueryObserverResult,\n  QueryObserverLoadingErrorResult,\n  QueryObserverSuccessResult,\n} from '@tanstack/query-core';\nimport {\n  filter,\n  map,\n  MonoTypeOperatorFunction,\n  OperatorFunction,\n  startWith,\n  takeWhile,\n  tap,\n} from 'rxjs';\nimport { createPendingObserverResult } from './utils';\n\nexport function mapResultData<T extends QueryObserverResult, R>(\n  mapFn: (data: NonNullable<T['data']>) => R,\n): OperatorFunction<T, QueryObserverResult<R>> {\n  return map((result) => {\n    return {\n      ...result,\n      data: result.isSuccess\n        ? mapFn(result.data as NonNullable<T['data']>)\n        : result.data,\n    } as QueryObserverResult<R>;\n  });\n}\n\nexport function filterSuccessResult<T>(): OperatorFunction<\n  QueryObserverResult<T>,\n  QueryObserverSuccessResult<T>\n> {\n  return filter(\n    (result): result is QueryObserverSuccessResult<T> => result.isSuccess,\n  );\n}\n\nexport function filterErrorResult<T, E>(): OperatorFunction<\n  QueryObserverResult<T, E>,\n  QueryObserverLoadingErrorResult<T, E>\n> {\n  return filter(\n    (result): result is QueryObserverLoadingErrorResult<T, E> =>\n      result.status === 'error',\n  );\n}\n\nexport function tapSuccessResult<T extends QueryObserverResult>(\n  cb: (data: NonNullable<T['data']>) => void,\n) {\n  return tap<T>((result) => {\n    if (result.isSuccess) {\n      cb(result.data as NonNullable<T['data']>);\n    }\n  });\n}\n\nexport function tapErrorResult<T extends QueryObserverResult>(\n  cb: (error: NonNullable<T['error']>) => void,\n) {\n  return tap<T>((result) => {\n    if (result.isError) {\n      cb(result.error as NonNullable<T['error']>);\n    }\n  });\n}\n\n/**\n * An operator that takes values emitted by the source observable\n * until the `isFetching` property on the result is false.\n * It is intended to be used in scenarios where an observable stream should be listened to\n * until the result has finished fetching (e.g success or error).\n */\nexport function takeUntilResultFinalize<T extends QueryObserverResult>() {\n  return takeWhile((res: T) => res.isFetching, true);\n}\n\n/**\n * An operator that takes values emitted by the source observable\n * until the `isSuccess` property on the result is true.\n * It is intended to be used in scenarios where an observable stream should be listened to\n * until a successful result is emitted.\n */\nexport function takeUntilResultSuccess<T extends QueryObserverResult>() {\n  return takeWhile((res: T) => !res.isSuccess, true);\n}\n\n/**\n * An operator that takes values emitted by the source observable\n * until the `isError` property on the result is true.\n * It is intended to be used in scenarios where an observable stream should be listened to\n * until an error result is emitted.\n */\nexport function takeUntilResultError<T extends QueryObserverResult>() {\n  return takeWhile((res: T) => !res.isError, true);\n}\n\nexport function startWithPendingQueryResult<T>(): MonoTypeOperatorFunction<T> {\n  return startWith(\n    createPendingObserverResult(),\n  ) as MonoTypeOperatorFunction<T>;\n}\n\ntype DataTypes<\n  T extends QueryObserverResult[] | Record<string, QueryObserverResult<any>>,\n> = {\n  [P in keyof T]: T[P] extends QueryObserverResult<infer R> ? R : never;\n};\n\ntype UnifiedTypes<T> = T extends Array<QueryObserverResult<any>>\n  ? DataTypes<T>\n  : T extends Record<string, QueryObserverResult<any>>\n    ? DataTypes<T>\n    : never;\n\n/**\n *\n *  This operator is used to merge multiple queries into one.\n *  It will return a new base query result that will merge the results of all the queries.\n *\n * @example\n *\n * const query = combineLatest({\n *   todos: todos.result$,\n *   posts: posts.result$,\n * }).pipe(\n *   intersectResults$(({ todos, posts }) => {\n *     return { ... }\n *   })\n * )\n * @example\n *\n * const query = combineLatest([todos.result$, posts.result$]).pipe(\n *   intersectResults$(([todos, posts]) => {\n *     return { ... }\n *   })\n * )\n */\nexport function intersectResults$<\n  T extends\n    | Array<QueryObserverResult<any>>\n    | Record<string, QueryObserverResult<any>>,\n  R,\n>(\n  mapFn: (values: UnifiedTypes<T>) => R,\n): OperatorFunction<T, QueryObserverResult<R> & { all: T }> {\n  return map((values) => {\n    const isArray = Array.isArray(values);\n    const toArray = isArray ? values : Object.values(values);\n    const refetch = () => Promise.all(toArray.map(v => v.refetch()));\n\n    const mappedResult = {\n      all: values,\n      isSuccess: toArray.every((v) => v.isSuccess),\n      isPending: toArray.some((v) => v.isPending),\n      isLoading: toArray.some((v) => v.isLoading),\n      isError: toArray.some((v) => v.isError),\n      isFetching: toArray.some((v) => v.isFetching),\n      error: toArray.find((v) => v.isError)?.error,\n      data: undefined,\n      refetch,\n    } as unknown as QueryObserverResult<R> & { all: T };\n\n    if (mappedResult.isSuccess) {\n      if (isArray) {\n        mappedResult.data = mapFn(\n          toArray.map((r) => r.data) as UnifiedTypes<T>,\n        );\n      } else {\n        const data = Object.entries(values).reduce((acc, [key, value]) => {\n          acc[key as keyof UnifiedTypes<T>] = value.data;\n\n          return acc;\n        }, {} as UnifiedTypes<T>);\n\n        mappedResult.data = mapFn(data);\n      }\n    }\n\n    return mappedResult;\n  });\n}\n","import { Signal, computed } from '@angular/core';\nimport {\n  QueryObserverBaseResult,\n  QueryObserverResult,\n} from '@tanstack/query-core';\n\ntype DataTypes<\n  T extends\n    | Array<Signal<QueryObserverBaseResult>>\n    | Record<string, Signal<QueryObserverBaseResult<any>>>,\n> = {\n  [P in keyof T]: T[P] extends Signal<QueryObserverBaseResult<infer R>>\n    ? R\n    : never;\n};\n\ntype UnifiedTypes<T> = T extends Array<Signal<QueryObserverBaseResult<any>>>\n  ? DataTypes<T>\n  : T extends Record<string, Signal<QueryObserverBaseResult<any>>>\n    ? DataTypes<T>\n    : never;\n\n/**\n *\n *  @experimental\n *\n *  This function is used to merge multiple signal queries into one.\n *  It will return a new base query result that will merge the results of all the queries.\n *  Note that it should be used inside injection context\n *\n * @example\n *\n * const query = intersetResults({\n *   todos: todos.result$,\n *   posts: posts.result$,\n * }, ({ todos, posts }) => {\n *   return todos + posts;\n * })\n *\n *\n * @example\n *\n * const query = intersectResults(\n *   [\n *     this.todosService.getTodo('1').result,\n *     this.todosService.getTodo('2').result,\n *   ],\n *  ([todoOne, todoTwo]) => {\n *    return todoOne.title + todoTwo.title;\n *  }\n * );\n */\nexport function intersectResults<\n  T extends\n    | Array<Signal<QueryObserverResult<any>>>\n    | Record<string, Signal<QueryObserverResult<any>>>,\n  R,\n>(\n  signals: T,\n  mapFn: (values: UnifiedTypes<T>) => R,\n): Signal<QueryObserverResult<R> & { all: T }> {\n  const isArray = Array.isArray(signals);\n  const toArray = isArray ? signals : Object.values(signals);\n  const refetch = () => Promise.all(toArray.map(v => v().refetch()));\n\n  return computed(() => {\n    const mappedResult = {\n      all: signals,\n      isSuccess: toArray.every((v) => v().isSuccess),\n      isPending: toArray.some((v) => v().isPending),\n      isLoading: toArray.some((v) => v().isLoading),\n      isError: toArray.some((v) => v().isError),\n      isFetching: toArray.some((v) => v().isFetching),\n      error: toArray.find((v) => v().isError)?.error,\n      data: undefined,\n      refetch,\n    } as unknown as QueryObserverResult<R> & { all: T };\n\n    if (mappedResult.isSuccess) {\n      if (isArray) {\n        mappedResult.data = mapFn(\n          toArray.map((r) => r().data) as UnifiedTypes<T>,\n        );\n      } else {\n        const data = Object.entries(signals).reduce((acc, [key, value]) => {\n          acc[key as keyof UnifiedTypes<T>] = value().data;\n\n          return acc;\n        }, {} as UnifiedTypes<T>);\n\n        mappedResult.data = mapFn(data);\n      }\n    }\n\n    return mappedResult;\n  });\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["_QueryClient"],"mappings":";;;;;;;;AAOO,MAAM,oBAAoB,GAAG,IAAI,cAAc,CACpD,sBAAsB,EACtB;AACE,IAAA,UAAU,EAAE,MAAM;IAClB,OAAO,GAAA;AACL,QAAA,OAAO,EAAE,CAAC;KACX;AACF,CAAA,CACF,CAAC;AAUI,SAAU,yBAAyB,CACvC,OAAgD,EAAA;AAEhD,IAAA,OAAO,wBAAwB,CAAC;AAC9B,QAAA;AACE,YAAA,OAAO,EAAE,oBAAoB;AAC7B,YAAA,CAAC,OAAO,OAAO,KAAK,UAAU,GAAG,YAAY,GAAG,UAAU,GAAG,OAAO;AAC9D,SAAA;AACT,KAAA,CAAC,CAAC;AACL;;SC3BgB,SAAS,CAAI,EAC3B,MAAM,EACN,MAAM,GAIP,EAAA;AACC,IAAA,MAAM,MAAM,GAAG,IAAI,OAAO,EAAQ,CAAC;IAEnC,IAAI,MAAM,EAAE;AACV,QAAA,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,MAAK;YACpC,MAAM,CAAC,IAAI,EAAE,CAAC;YACd,MAAM,CAAC,QAAQ,EAAE,CAAC;AACpB,SAAC,CAAC,CAAC;KACJ;IAED,OAAO,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AAC5E,CAAC;AAEK,SAAU,2BAA2B,CACzC,IAAO,EAAA;IAEP,OAAO;QACL,IAAI;AACJ,QAAA,SAAS,EAAE,KAAK;AAChB,QAAA,OAAO,EAAE,KAAK;AACd,QAAA,UAAU,EAAE,KAAK;AACjB,QAAA,SAAS,EAAE,KAAK;AAChB,QAAA,SAAS,EAAE,IAAI;AACf,QAAA,MAAM,EAAE,SAAS;KACsB,CAAC;AAC5C,CAAC;SAEe,2BAA2B,GAAA;IAIzC,OAAO;AACL,QAAA,OAAO,EAAE,KAAK;AACd,QAAA,SAAS,EAAE,IAAI;AACf,QAAA,SAAS,EAAE,IAAI;AACf,QAAA,UAAU,EAAE,IAAI;AAChB,QAAA,SAAS,EAAE,KAAK;AAChB,QAAA,WAAW,EAAE,UAAU;AACvB,QAAA,MAAM,EAAE,SAAS;KACe,CAAC;AACrC,CAAC;AAEe,SAAA,gBAAgB,CAC9B,UAAmC,EACnC,MAAqB,EAAA;AAErB,IAAA,IAAI,OAAO,UAAU,KAAK,UAAU,EAAE;AACpC,QAAA,OAAO,UAAU,CAAC,GAAG,MAAM,CAAC,CAAC;KAC9B;IAED,OAAO,CAAC,CAAC,UAAU,CAAC;AACtB;;AC8BM,SAAU,YAAY,CAAC,OAAgB,EAAA;AAC3C,IAAA,OAAO,OAAO,CAAC;AACjB,CAAC;SAEe,gBAAgB,CAQ9B,MAAmB,EACnB,OAOC,EACD,QAAkB,EAAA;IAElB,MAAM,gBAAgB,GAAG,MAAM,CAAC,mBAAmB,CACjD,OAA0C,CAC3C,CAAC;AACF,IAAA,gBAAgB,CAAC,kBAAkB,GAAG,YAAY,CAAC;AAEnD,IAAA,MAAM,eAAe,GAAG,gBAAgB,CAAC,OAAO,CAAC;IAEjD,IAAI,eAAe,EAAE;AACnB,QAAA,gBAAgB,CAAC,OAAO,GAAG,UAAU,GAAyB,EAAA;;YAE5D,MAAM,KAAK,GAAG,IAAI,CAAC;AAEnB,YAAA,OAAO,qBAAqB,CAAC,QAAQ,EAAE,MAAK;gBAC1C,MAAM,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAE/C,gBAAA,IAAI,YAAY,CAAC,KAAK,CAAC,EAAE;AACvB,oBAAA,OAAO,SAAS,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC;iBACzD;AAED,gBAAA,OAAO,KAAK,CAAC;AACf,aAAC,CAAC,CAAC;AACL,SAAC,CAAC;KACH;AAED,IAAA,OAAO,gBAAgB,CAAC;AAC1B;;ACrHA,MAAM,gBAAgB,GAAG,IAAI,cAAc,CAAc,aAAa,EAAE;AACtE,IAAA,UAAU,EAAE,MAAM;IAClB,OAAO,GAAA;QACL,OAAO,IAAI,WAAW,CAAC,MAAM,CAAC,oBAAoB,CAAC,CAAC,CAAC;KACtD;AACF,CAAA,CAAC,CAAC;AAEH,MAGM,gBAAgB,CAAA;AAGpB,IAAA,WAAA,GAAA;AAFA,QAAA,IAAA,CAAA,QAAQ,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAC;AAGlC,QAAA,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;KACvB;IAED,WAAW,GAAA;AACT,QAAA,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;KACzB;8GATG,gBAAgB,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA,EAAA;AAAhB,IAAA,SAAA,IAAA,CAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,gBAAgB,cAFR,MAAM,EAAA,CAAA,CAAA,EAAA;;2FAEd,gBAAgB,EAAA,UAAA,EAAA,CAAA;kBAHrB,UAAU;AAAC,YAAA,IAAA,EAAA,CAAA;AACV,oBAAA,UAAU,EAAE,MAAM;AACnB,iBAAA,CAAA;;AAaD,MAAM,kBAAkB,GAAG,IAAI,cAAc,CAC3C,oBAAoB,EACpB;AACE,IAAA,UAAU,EAAE,MAAM;IAClB,OAAO,GAAA;QACL,IAAI,iBAAiB,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,EAAE;YAC1C,MAAM,CAAC,gBAAgB,CAAC,CAAC;SAC1B;AAED,QAAA,OAAO,MAAM,CAAC,gBAAgB,CAAC,CAAC;KACjC;AACF,CAAA,CACF,CAAC;AAEF;AACM,SAAU,kBAAkB,CAAC,WAAwB,EAAA;IACzD,OAAO;AACL,QAAA,OAAO,EAAE,gBAAgB;AACzB,QAAA,QAAQ,EAAE,WAAW;KACtB,CAAC;AACJ,CAAC;AAED;SACgB,iBAAiB,GAAA;AAC/B,IAAA,OAAO,MAAM,CAAC,kBAAkB,CAAC,CAAC;AACpC,CAAC;AAED;AACM,MAAO,WAAY,SAAQA,aAAY,CAAA;AAC3C,IAAA,SAAS,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AAqCpB,IAAA,eAAe,CAMtB,OAMC,EAAA;AAED,QAAA,MAAM,gBAAgB,GAAG,gBAAgB,CACvC,IAAI,EACJ,OAMC,EACD,IAAI,CAAC,SAAS,CAOf,CAAC;AACF,QAAA,OAAO,KAAK,CAAC,eAAe,CAAC,gBAAgB,CAAC,CAAC;KAChD;AAkDQ,IAAA,UAAU,CAOjB,OAOC,EAAA;AAED,QAAA,MAAM,gBAAgB,GAAG,gBAAgB,CACvC,IAAI,EACJ,OAOC,EACD,IAAI,CAAC,SAAS,CAOf,CAAC;AACF,QAAA,OAAO,KAAK,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC;KAC3C;AAsCQ,IAAA,aAAa,CAMpB,OAMC,EAAA;AAED,QAAA,MAAM,gBAAgB,GAAG,gBAAgB,CACvC,IAAI,EACJ,OAMC,EACD,IAAI,CAAC,SAAS,CAOf,CAAC;AACF,QAAA,OAAO,KAAK,CAAC,aAAa,CAAC,gBAAgB,CAAC,CAAC;KAC9C;AA4CQ,IAAA,kBAAkB,CAOzB,OAOC,EAAA;AAED,QAAA,MAAM,gBAAgB,GAAG,gBAAgB,CACvC,IAAI,EACJ,OAOC,EACD,IAAI,CAAC,SAAS,CAOf,CAAC;AACF,QAAA,OAAO,KAAK,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,CAAC;KACnD;AA4CQ,IAAA,qBAAqB,CAO5B,OAOC,EAAA;AAED,QAAA,MAAM,gBAAgB,GAAG,gBAAgB,CACvC,IAAI,EACJ,OAOC,EACD,IAAI,CAAC,SAAS,CAOf,CAAC;AACF,QAAA,OAAO,KAAK,CAAC,qBAAqB,CAAC,gBAAgB,CAAC,CAAC;KACtD;AACF;;ACtYK,SAAU,eAAe,CAM7B,EACA,MAAM,EACN,QAAQ,EACR,OAAO,EACP,QAAQ,GAYT,EAAA;AACC,IAAA,IAAI,aAES,CAAC;IAEd,MAAM,gBAAgB,GAAG,gBAAgB,CACvC,MAAM,EACN,OAMC,EACD,QAAQ,CACT,CAAC;IAEF,MAAM,OAAO,GAAG,IAAI,UAAU,CAAC,CAAC,QAAQ,KAAI;;QAE1C,IAAI,CAAC,aAAa,EAAE;YAClB,aAAa,GAAG,IAAI,QAAQ,CAM1B,MAAM,EAAE,gBAAuB,CAAC,CAAC;SACpC;QAED,QAAQ,CAAC,IAAI,CAAC,aAAa,CAAC,mBAAmB,CAAC,gBAAuB,CAAC,CAAC,CAAC;AAE1E,QAAA,MAAM,oBAAoB,GAAG,aAAa,CAAC,SAAS,CAClD,aAAa,CAAC,UAAU,CAAC,CAAC,MAAM,KAAI;YAClC,IACE,CAAC,MAAM,CAAC,UAAU;AAClB,gBAAA,MAAM,CAAC,OAAO;AACd,gBAAA,gBAAgB,CAAC,aAAc,CAAC,OAAO,CAAC,YAAY,EAAE;AACpD,oBAAA,MAAM,CAAC,KAAK;oBACZ,aAAc,CAAC,eAAe,EAAE;AACjC,iBAAA,CAAC,EACF;AACA,gBAAA,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;aAC9B;iBAAM;AACL,gBAAA,QAAQ,CAAC,IAAI,CACX,gBAAgB,CAAC,mBAAmB;AAClC,sBAAE,MAAM;sBACN,aAAa,EAAE,WAAW,CAAC,MAAM,CAAC,CACvC,CAAC;aACH;SACF,CAAC,CACH,CAAC;AAEF,QAAA,OAAO,MAAK;AACV,YAAA,oBAAoB,EAAE,CAAC;YACvB,aAAa,GAAG,SAAS,CAAC;AAC5B,SAAC,CAAC;AACJ,KAAC,CAAC,CAAC,IAAI,CACL,WAAW,CAAC;AACV,QAAA,UAAU,EAAE,CAAC;AACb,QAAA,QAAQ,EAAE,IAAI;AACf,KAAA,CAAC,CACH,CAAC;AAEF,IAAA,IAAI,YAAqC,CAAC;IAC1C,MAAM,cAAc,GAAG,QAAQ,IAAK,QAAgB,CAAC,QAAQ,CAAC,CAAC;IAE/D,OAAO;QACL,OAAO;AACP,QAAA,aAAa,EAAE,CAAC,UAAyC,KAAI;YAC3D,IAAI,aAAa,EAAE;AACjB,gBAAA,MAAM,UAAU,GAAG,gBAAgB,CACjC,MAAM,EACN;AACE,oBAAA,GAAI,OAA2C;AAC/C,oBAAA,GAAG,UAAU;iBACd,EACD,QAAQ,CAOT,CAAC;gBAEF,aAAa,CAAC,UAAU,CAAC,UAAU,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;aAC5D;SACF;;AAED,QAAA,IAAI,MAAM,GAAA;AACR,YAAA,CAAC,cAAc;gBACb,wBAAwB,CAAC,SAAS,iBAAiB,GAAA;;AAEnD,iBAAC,CAAC,CAAC;YAEL,IAAI,CAAC,YAAY,EAAE;AACjB,gBAAA,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE;AACpC,oBAAA,WAAW,EAAE,IAAI;;;;;;oBAMjB,QAAQ,EAAE,cAAc,GAAG,QAAQ,GAAG,SAAS;AAChD,iBAAA,CAAC,CAAC;aACJ;AAED,YAAA,OAAO,YAAY,CAAC;SACrB;KACF,CAAC;AACJ;;ACtIA,MACM,aAAa,CAAA;IACjB,SAAS,GAAG,iBAAiB,EAAE,CAAC;AAChC,IAAA,SAAS,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AAE7B,IAAA,GAAG,CAOD,OAOC,EAAA;AAED,QAAA,OAAO,eAAe,CAAC;YACrB,MAAM,EAAE,IAAI,CAAC,SAAS;AACtB,YAAA,QAAQ,EAAE,OAAO,CAAC,QAAQ,IAAI,IAAI,CAAC,SAAS;AAC5C,YAAA,QAAQ,EAAE,qBAA6C;AACvD,YAAA,OAAO,EAAE,OAAc;AACxB,SAAA,CAAC,CAAC;KACJ;8GA1BG,aAAa,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA,EAAA;AAAb,IAAA,SAAA,IAAA,CAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,aAAa,cADO,MAAM,EAAA,CAAA,CAAA,EAAA;;2FAC1B,aAAa,EAAA,UAAA,EAAA,CAAA;kBADlB,UAAU;mBAAC,EAAE,UAAU,EAAE,MAAM,EAAE,CAAA;;AA8B5B,SAAU,mBAAmB,CAAC,OAAiC,EAAA;AACnE,IAAA,IAAI,OAAO,EAAE,QAAQ,EAAE;AACrB,QAAA,OAAO,qBAAqB,CAAC,OAAO,CAAC,QAAQ,EAAE,MAAK;AAClD,YAAA,MAAM,KAAK,GAAG,MAAM,CAAC,aAAa,CAAC,CAAC;YAEpC,OAAO,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC/B,SAAC,CAAC,CAAC;KACJ;IAED,wBAAwB,CAAC,mBAAmB,CAAC,CAAC;AAE9C,IAAA,MAAM,KAAK,GAAG,MAAM,CAAC,aAAa,CAAC,CAAC;IAEpC,OAAO,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC/B;;MCnGa,UAAU,CAAA;IACrB,YAAY,GAAG,iBAAiB,EAAE,CAAC;AAEnC,IAAA,GAAG,CAAC,OAAsB,EAAA;QACxB,MAAM,OAAO,GAAG,IAAI,UAAU,CAAS,CAAC,QAAQ,KAAI;AAClD,YAAA,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;AACrD,YAAA,MAAM,mBAAmB,GAAG,IAAI,CAAC,YAAY,CAAC,aAAa,EAAE,CAAC,SAAS,CACrE,aAAa,CAAC,UAAU,CAAC,MAAK;AAC5B,gBAAA,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;aACtD,CAAC,CACH,CAAC;AAEF,YAAA,OAAO,MAAM,mBAAmB,EAAE,CAAC;AACrC,SAAC,CAAC,CAAC,IAAI,CAAC,oBAAoB,EAAE,CAAC,CAAC;QAEhC,OAAO;YACL,OAAO;AACP,YAAA,QAAQ,EAAE,MAAM,QAAQ,CAAC,OAAO,CAAC;SAClC,CAAC;KACH;8GAnBU,UAAU,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA,EAAA;AAAV,IAAA,SAAA,IAAA,CAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,UAAU,cADG,MAAM,EAAA,CAAA,CAAA,EAAA;;2FACnB,UAAU,EAAA,UAAA,EAAA,CAAA;kBADtB,UAAU;mBAAC,EAAE,UAAU,EAAE,MAAM,EAAE,CAAA;;AAuBlC,MAAM,aAAa,GAAG,IAAI,cAAc,CAAoB,eAAe,EAAE;AAC3E,IAAA,UAAU,EAAE,MAAM;IAClB,OAAO,GAAA;AACL,QAAA,MAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;QACpC,OAAO,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;KACxC;AACF,CAAA,CAAC,CAAC;SAEa,gBAAgB,GAAA;IAC9B,wBAAwB,CAAC,gBAAgB,CAAC,CAAC;AAC3C,IAAA,OAAO,MAAM,CAAC,aAAa,CAAC,CAAC;AAC/B;;MCjCa,UAAU,CAAA;IACrB,YAAY,GAAG,iBAAiB,EAAE,CAAC;AAEnC,IAAA,GAAG,CAAC,OAAyB,EAAA;QAC3B,MAAM,OAAO,GAAG,IAAI,UAAU,CAAS,CAAC,QAAQ,KAAI;AAClD,YAAA,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;AACrD,YAAA,MAAM,mBAAmB,GAAG,IAAI,CAAC,YAAY;AAC1C,iBAAA,gBAAgB,EAAE;AAClB,iBAAA,SAAS,CACR,aAAa,CAAC,UAAU,CAAC,MAAK;AAC5B,gBAAA,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;aACtD,CAAC,CACH,CAAC;AAEJ,YAAA,OAAO,MAAM,mBAAmB,EAAE,CAAC;AACrC,SAAC,CAAC,CAAC,IAAI,CAAC,oBAAoB,EAAE,CAAC,CAAC;QAEhC,OAAO;YACL,OAAO;AACP,YAAA,QAAQ,EAAE,MAAM,QAAQ,CAAC,OAAO,CAAC;SAClC,CAAC;KACH;8GArBU,UAAU,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA,EAAA;AAAV,IAAA,SAAA,IAAA,CAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,UAAU,cADG,MAAM,EAAA,CAAA,CAAA,EAAA;;2FACnB,UAAU,EAAA,UAAA,EAAA,CAAA;kBADtB,UAAU;mBAAC,EAAE,UAAU,EAAE,MAAM,EAAE,CAAA;;AAyBlC,MAAM,aAAa,GAAG,IAAI,cAAc,CAAoB,eAAe,EAAE;AAC3E,IAAA,UAAU,EAAE,MAAM;IAClB,OAAO,GAAA;AACL,QAAA,MAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;QACpC,OAAO,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;KACxC;AACF,CAAA,CAAC,CAAC;SAEa,gBAAgB,GAAA;IAC9B,wBAAwB,CAAC,gBAAgB,CAAC,CAAC;AAE3C,IAAA,OAAO,MAAM,CAAC,aAAa,CAAC,CAAC;AAC/B;;ACKA,MACM,QAAQ,CAAA;IACZ,SAAS,GAAG,iBAAiB,EAAE,CAAC;AAEhC,IAAA,GAAG,CAMD,OAAmE,EAAA;QAEnE,MAAM,gBAAgB,GAAG,IAAI,gBAAgB,CAK3C,IAAI,CAAC,SAAS,EAAE;AAChB,YAAA,GAAG,OAAO;AACV,YAAA,UAAU,EAAE,CAAC,SAAqB,KAAoB;gBACpD,MAAM,MAAM,GACV,OAAO,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;gBAEhC,IAAI,YAAY,CAAC,MAAM,CAAC;AAAE,oBAAA,OAAO,SAAS,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC;AAEvD,gBAAA,OAAO,MAAM,CAAC;aACf;AACF,SAAA,CAAC,CAAC;QAEH,MAAM,OAAO,GAAG,IAAI,UAAU,CAE5B,CAAC,QAAQ,KAAI;YACb,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,gBAAgB,EAAE,CAAC,CAAC;AAEnD,YAAA,MAAM,mBAAmB,GAAG,gBAAgB,CAAC,SAAS,CACpD,aAAa,CAAC,UAAU,CACtB,CACE,MAAmE,KACjE;gBACF,IACE,MAAM,CAAC,OAAO;AACd,oBAAA,gBAAgB,CAAC,gBAAiB,CAAC,OAAO,CAAC,YAAY,EAAE;AACvD,wBAAA,MAAM,CAAC,KAAK;AACb,qBAAA,CAAC,EACF;AACA,oBAAA,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBAC9B;qBAAM;AACL,oBAAA,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;iBACvB;aACF,CACF,CACF,CAAC;AAEF,YAAA,OAAO,MAAM,mBAAmB,EAAE,CAAC;AACrC,SAAC,CAAC,CAAC,IAAI,CACL,WAAW,CAAC;AACV,YAAA,UAAU,EAAE,CAAC;AACb,YAAA,QAAQ,EAAE,IAAI;AACf,SAAA,CAAC,CACH,CAAC;AAEF,QAAA,MAAM,MAAM,GAAG,CACb,SAAqB,EACrB,OAA4D,KAC1D;YACF,gBAAgB,CAAC,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC,KAAK,CAAC,MAAK;;AAEvD,aAAC,CAAC,CAAC;AACL,SAAC,CAAC;AAEF,QAAA,IAAI,YAAqC,CAAC;QAE1C,OAAO;YACL,MAAM;YACN,WAAW,EAAE,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC;YAC3D,KAAK,EAAE,gBAAgB,CAAC,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC;YACpD,UAAU,EAAE,gBAAgB,CAAC,UAAU,CAAC,IAAI,CAAC,gBAAgB,CAAC;YAC9D,OAAO;;AAEP,YAAA,IAAI,MAAM,GAAA;gBACR,IAAI,CAAC,YAAY,EAAE;AACjB,oBAAA,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC,CAAC;iBAC9D;AAED,gBAAA,OAAO,YAAY,CAAC;aACrB;SACF,CAAC;KACH;8GAtFG,QAAQ,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA,EAAA;AAAR,IAAA,SAAA,IAAA,CAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,QAAQ,cADY,MAAM,EAAA,CAAA,CAAA,EAAA;;2FAC1B,QAAQ,EAAA,UAAA,EAAA,CAAA;kBADb,UAAU;mBAAC,EAAE,UAAU,EAAE,MAAM,EAAE,CAAA;;AA0FlC,MAAM,WAAW,GAAG,IAAI,cAAc,CAAC,aAAa,EAAE;AACpD,IAAA,UAAU,EAAE,MAAM;IAClB,OAAO,GAAA;AACL,QAAA,MAAM,QAAQ,GAAG,IAAI,QAAQ,EAAE,CAAC;QAChC,OAAO,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;KACpC;AACF,CAAA,CAAC,CAAC;SAEa,cAAc,GAAA;AAC5B,IAAA,OAAO,MAAM,CAAC,WAAW,CAAC,CAAC;AAC7B;;AClIA,MACM,KAAK,CAAA;IACT,SAAS,GAAG,iBAAiB,EAAE,CAAC;AAChC,IAAA,SAAS,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AAyB7B,IAAA,GAAG,CAMD,OAMC,EAAA;AAED,QAAA,OAAO,eAAe,CAAC;YACrB,MAAM,EAAE,IAAI,CAAC,SAAS;AACtB,YAAA,QAAQ,EAAE,OAAO,CAAC,QAAQ,IAAI,IAAI,CAAC,SAAS;AAC5C,YAAA,QAAQ,EAAE,aAAa;YACvB,OAAO;AACR,SAAA,CAAC,CAAC;KACJ;8GA/CG,KAAK,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA,EAAA;AAAL,IAAA,SAAA,IAAA,CAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,KAAK,cADe,MAAM,EAAA,CAAA,CAAA,EAAA;;2FAC1B,KAAK,EAAA,UAAA,EAAA,CAAA;kBADV,UAAU;mBAAC,EAAE,UAAU,EAAE,MAAM,EAAE,CAAA;;AAmDlC;;;;;;;;;;;;;AAaG;AACG,SAAU,WAAW,CAAC,OAAiC,EAAA;AAC3D,IAAA,IAAI,OAAO,EAAE,QAAQ,EAAE;AACrB,QAAA,OAAO,qBAAqB,CAAC,OAAO,CAAC,QAAQ,EAAE,MAAK;AAClD,YAAA,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;YAE5B,OAAO,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC/B,SAAC,CAAC,CAAC;KACJ;IAED,wBAAwB,CAAC,WAAW,CAAC,CAAC;AAEtC,IAAA,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IAE5B,OAAO,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC/B;;ACtFM,SAAU,aAAa,CAC3B,KAA0C,EAAA;AAE1C,IAAA,OAAO,GAAG,CAAC,CAAC,MAAM,KAAI;QACpB,OAAO;AACL,YAAA,GAAG,MAAM;YACT,IAAI,EAAE,MAAM,CAAC,SAAS;AACpB,kBAAE,KAAK,CAAC,MAAM,CAAC,IAA8B,CAAC;kBAC5C,MAAM,CAAC,IAAI;SACU,CAAC;AAC9B,KAAC,CAAC,CAAC;AACL,CAAC;SAEe,mBAAmB,GAAA;IAIjC,OAAO,MAAM,CACX,CAAC,MAAM,KAA8C,MAAM,CAAC,SAAS,CACtE,CAAC;AACJ,CAAC;SAEe,iBAAiB,GAAA;AAI/B,IAAA,OAAO,MAAM,CACX,CAAC,MAAM,KACL,MAAM,CAAC,MAAM,KAAK,OAAO,CAC5B,CAAC;AACJ,CAAC;AAEK,SAAU,gBAAgB,CAC9B,EAA0C,EAAA;AAE1C,IAAA,OAAO,GAAG,CAAI,CAAC,MAAM,KAAI;AACvB,QAAA,IAAI,MAAM,CAAC,SAAS,EAAE;AACpB,YAAA,EAAE,CAAC,MAAM,CAAC,IAA8B,CAAC,CAAC;SAC3C;AACH,KAAC,CAAC,CAAC;AACL,CAAC;AAEK,SAAU,cAAc,CAC5B,EAA4C,EAAA;AAE5C,IAAA,OAAO,GAAG,CAAI,CAAC,MAAM,KAAI;AACvB,QAAA,IAAI,MAAM,CAAC,OAAO,EAAE;AAClB,YAAA,EAAE,CAAC,MAAM,CAAC,KAAgC,CAAC,CAAC;SAC7C;AACH,KAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;AAKG;SACa,uBAAuB,GAAA;AACrC,IAAA,OAAO,SAAS,CAAC,CAAC,GAAM,KAAK,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;AACrD,CAAC;AAED;;;;;AAKG;SACa,sBAAsB,GAAA;AACpC,IAAA,OAAO,SAAS,CAAC,CAAC,GAAM,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;AACrD,CAAC;AAED;;;;;AAKG;SACa,oBAAoB,GAAA;AAClC,IAAA,OAAO,SAAS,CAAC,CAAC,GAAM,KAAK,CAAC,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AACnD,CAAC;SAEe,2BAA2B,GAAA;AACzC,IAAA,OAAO,SAAS,CACd,2BAA2B,EAAE,CACC,CAAC;AACnC,CAAC;AAcD;;;;;;;;;;;;;;;;;;;;;;AAsBG;AACG,SAAU,iBAAiB,CAM/B,KAAqC,EAAA;AAErC,IAAA,OAAO,GAAG,CAAC,CAAC,MAAM,KAAI;QACpB,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;AACtC,QAAA,MAAM,OAAO,GAAG,OAAO,GAAG,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACzD,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;AAEjE,QAAA,MAAM,YAAY,GAAG;AACnB,YAAA,GAAG,EAAE,MAAM;AACX,YAAA,SAAS,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC;AAC5C,YAAA,SAAS,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC;AAC3C,YAAA,SAAS,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC;AAC3C,YAAA,OAAO,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC;AACvC,YAAA,UAAU,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC;AAC7C,YAAA,KAAK,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,EAAE,KAAK;AAC5C,YAAA,IAAI,EAAE,SAAS;YACf,OAAO;SAC0C,CAAC;AAEpD,QAAA,IAAI,YAAY,CAAC,SAAS,EAAE;YAC1B,IAAI,OAAO,EAAE;AACX,gBAAA,YAAY,CAAC,IAAI,GAAG,KAAK,CACvB,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAoB,CAC9C,CAAC;aACH;iBAAM;gBACL,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,KAAK,CAAC,KAAI;AAC/D,oBAAA,GAAG,CAAC,GAA4B,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC;AAE/C,oBAAA,OAAO,GAAG,CAAC;iBACZ,EAAE,EAAqB,CAAC,CAAC;AAE1B,gBAAA,YAAY,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;aACjC;SACF;AAED,QAAA,OAAO,YAAY,CAAC;AACtB,KAAC,CAAC,CAAC;AACL;;AChKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BG;AACa,SAAA,gBAAgB,CAM9B,OAAU,EACV,KAAqC,EAAA;IAErC,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;AACvC,IAAA,MAAM,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAC3D,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;IAEnE,OAAO,QAAQ,CAAC,MAAK;AACnB,QAAA,MAAM,YAAY,GAAG;AACnB,YAAA,GAAG,EAAE,OAAO;AACZ,YAAA,SAAS,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,SAAS,CAAC;AAC9C,YAAA,SAAS,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,SAAS,CAAC;AAC7C,YAAA,SAAS,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,SAAS,CAAC;AAC7C,YAAA,OAAO,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,OAAO,CAAC;AACzC,YAAA,UAAU,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,UAAU,CAAC;AAC/C,YAAA,KAAK,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,OAAO,CAAC,EAAE,KAAK;AAC9C,YAAA,IAAI,EAAE,SAAS;YACf,OAAO;SAC0C,CAAC;AAEpD,QAAA,IAAI,YAAY,CAAC,SAAS,EAAE;YAC1B,IAAI,OAAO,EAAE;gBACX,YAAY,CAAC,IAAI,GAAG,KAAK,CACvB,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAoB,CAChD,CAAC;aACH;iBAAM;gBACL,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,KAAK,CAAC,KAAI;oBAChE,GAAG,CAAC,GAA4B,CAAC,GAAG,KAAK,EAAE,CAAC,IAAI,CAAC;AAEjD,oBAAA,OAAO,GAAG,CAAC;iBACZ,EAAE,EAAqB,CAAC,CAAC;AAE1B,gBAAA,YAAY,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;aACjC;SACF;AAED,QAAA,OAAO,YAAY,CAAC;AACtB,KAAC,CAAC,CAAC;AACL;;AChGA;;AAEG;;;;"}