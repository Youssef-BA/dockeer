import { QueryObserverResult, QueryObserverLoadingErrorResult, QueryObserverSuccessResult } from '@tanstack/query-core';
import { MonoTypeOperatorFunction, OperatorFunction } from 'rxjs';
export declare function mapResultData<T extends QueryObserverResult, R>(mapFn: (data: NonNullable<T['data']>) => R): OperatorFunction<T, QueryObserverResult<R>>;
export declare function filterSuccessResult<T>(): OperatorFunction<QueryObserverResult<T>, QueryObserverSuccessResult<T>>;
export declare function filterErrorResult<T, E>(): OperatorFunction<QueryObserverResult<T, E>, QueryObserverLoadingErrorResult<T, E>>;
export declare function tapSuccessResult<T extends QueryObserverResult>(cb: (data: NonNullable<T['data']>) => void): MonoTypeOperatorFunction<T>;
export declare function tapErrorResult<T extends QueryObserverResult>(cb: (error: NonNullable<T['error']>) => void): MonoTypeOperatorFunction<T>;
/**
 * An operator that takes values emitted by the source observable
 * until the `isFetching` property on the result is false.
 * It is intended to be used in scenarios where an observable stream should be listened to
 * until the result has finished fetching (e.g success or error).
 */
export declare function takeUntilResultFinalize<T extends QueryObserverResult>(): MonoTypeOperatorFunction<T>;
/**
 * An operator that takes values emitted by the source observable
 * until the `isSuccess` property on the result is true.
 * It is intended to be used in scenarios where an observable stream should be listened to
 * until a successful result is emitted.
 */
export declare function takeUntilResultSuccess<T extends QueryObserverResult>(): MonoTypeOperatorFunction<T>;
/**
 * An operator that takes values emitted by the source observable
 * until the `isError` property on the result is true.
 * It is intended to be used in scenarios where an observable stream should be listened to
 * until an error result is emitted.
 */
export declare function takeUntilResultError<T extends QueryObserverResult>(): MonoTypeOperatorFunction<T>;
export declare function startWithPendingQueryResult<T>(): MonoTypeOperatorFunction<T>;
type DataTypes<T extends QueryObserverResult[] | Record<string, QueryObserverResult<any>>> = {
    [P in keyof T]: T[P] extends QueryObserverResult<infer R> ? R : never;
};
type UnifiedTypes<T> = T extends Array<QueryObserverResult<any>> ? DataTypes<T> : T extends Record<string, QueryObserverResult<any>> ? DataTypes<T> : never;
/**
 *
 *  This operator is used to merge multiple queries into one.
 *  It will return a new base query result that will merge the results of all the queries.
 *
 * @example
 *
 * const query = combineLatest({
 *   todos: todos.result$,
 *   posts: posts.result$,
 * }).pipe(
 *   intersectResults$(({ todos, posts }) => {
 *     return { ... }
 *   })
 * )
 * @example
 *
 * const query = combineLatest([todos.result$, posts.result$]).pipe(
 *   intersectResults$(([todos, posts]) => {
 *     return { ... }
 *   })
 * )
 */
export declare function intersectResults$<T extends Array<QueryObserverResult<any>> | Record<string, QueryObserverResult<any>>, R>(mapFn: (values: UnifiedTypes<T>) => R): OperatorFunction<T, QueryObserverResult<R> & {
    all: T;
}>;
export {};
